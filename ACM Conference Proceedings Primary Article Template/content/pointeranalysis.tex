\subsection{Pointer Analysis}

Pointer analysis is a fundamental and widely applied static analysis technique that aims to determine the possible objects or memory locations that the pointer variables in a program may reference during execution.
Among the earliest and most influential contributions in this area is the work of Andersen in 1994, known as Andersen's Analysis, which is flow-, context-, and field-insensitive \cite{andersen1994program}. 
This analysis also referred to as a subset based analysis, introduces subset constraints to model the relationships between pointer variables and the memory locations they can potentially point to. 
Following Andersen's work, Steensgaard proposed in 1996 a unification-based pointer analysis that operates with almost linear time complexity \cite{steensgaard1996points}.
Unlike Andersen's approach, Steensgard's analysis merges points-to-set wherever any aliasing between two pointer variables, leading to a coarser approximation of the points-to information. 
As a result, Steensgaard analysis sacrifices precision for scalability, making it significanlty faster and less precise than Andersen's analysis \cite{shapiro1997effects}.
\todo{Should write the difference between context, object, field, flow sensitivity here??.}
\todo{Should write about k-site sensitivity??.}
Since both Andersen's and Steensgaard's analyses are field-, context-, and flow-insensitive, many subsequent researchers sought to improve precision by introducing different forms of sensitivity.
In 1994, Emami et al., \cite{emami1994context} defined a pointer analysis that, while still flow-insensitive, was extended to be context-sensitive. 
Their formulation distinguished between ''may'' and ''must'' points-to relations, thereby enabling strong updates.
Later in 2002, Milanova et al., \cite{milanova2002parameterized} introduced object-sensitive pointer analysis as a novel form of context sensitivity tailored for flow-insensitive points-to-analysis for Java.
Through empirical evaluation, they demonstrated that object-sensitivity provides greater precision than the traditional call-site sensitivity in the context of object-oriented programs.
In 2011, Smaragdakis et al., \cite{smaragdakis2011pick} proposed type sensitivity, a different sensitivity approach that leverages the type information as the distinguishing context.
Subsequently, in 2013, Kastrinis et al., \cite{kastrinis2013hybrid} proposes a hybrid form of context sensitivity that selectively combines both object-sensitivity and call-site sensitivity.
Their experimental research showed that this selection hybrid approach yields higher precision than a naive, non-selective combination of the two sensitivities.

Following the foundational works in pointer analysis, researchers have continually sought to enhance both the precision and efficiency of these analyses.
Starting from 2009, significant strides have been made in optimizing pointer analysis techniques.

CFL reachability formulations gives very precise points to results but are computationally expensive \cite{xu2009scaling}. 
In 2009, Xu et al., \cite{xu2009scaling} introduced a novel staging approach which does cheap, conservative, context-sensitive pre analysis, that helps in identifying pairs of variables that cannot alias in the given calling context.
Using this pre-analysis information, the main CFL-reachability based pointer analysis is able to prune infeasible CFL paths and thus improve both efficiency and precision.

In 2009, Hardekopf et al., \cite{hardekopf2009semi} introduces a flow-sensitive, context-insensitive pointer analysis that combines two key innovations: semi-sparse analysis and novel use of BDD's (Binary Decision Diagrams) to efficiently represent large points-to sets.
Their approach employs a partial static single assignment form, which allows for a sparse analysis on top-level variables (those whose addresses are not taken), while performing a standard iterative dataflow algorithm for the remaining variables.
Additionally, the use of BDDs enables compact representation of points-to information \cite{bryant1986graph} significantly reducing both memory usage and runtime compared to traditional flow-sensitive analyses.
Empirical results reported in their work demonstrate that this analysis scales to large programs while maintaining high precision.

In 2009, Lundberg et al., \cite{lundberg2009fast} introduced a context- and flow-sensitive pointer analysis approach that significanlty improves upon traditional methods in terms of both speed and precision.
Their analysis employed a graph-based Static Single Assignment (SSA) form, which extends the conventional SSA form \cite{ssa} to effectively represent points-to information.
In this representation, each method is modeled as a graph where nodes correspond to operations within the method, and edges denote data dependencies between these operations.
By leveraging SSA form, their analysis maintains strict flow-sensitivity.
They also introduced "this-sensitivity". This technique analyses methods seperately for each abstract object reaching the implicit this variable, thereby distinguishing between different calling contexts.
Empirical evaluations demonstrated that their 1-this-sensitivity analysis is considerably faster than the traditional context-sensitive and object-sensitivity analyses.

In 2010, Mendez-Lojo et al., \cite{mendez2010parallel} presented the first parallel implementation of Andersen's inclusion based points-to analysis, developed in Java. 
They showed that the inclusion-based points-to analysis can be expressed entirely in terms of graph rewriting rules.
Their central insight of their approach is that, during the rewriting phase, two active nodes can be processed parallel if do not interfere with each other.
Thus, identifying non-interfering active nodes becomes the key to unlock parallelism.
They leveraged the Galois system \cite{galois} to implement their parallel points-to analysis.
The implementation employed two main data structures (i) BDD's with hash table for storing points-to edges, and (ii) sparse bit vector based on linked list for storing other edges. 
The authors compared their experimental results with those reported by Hardekopf's 'cite{hardekopf2009semi}.
However, the results are not directly comparable, since their implementation was in Java, while Hardekopf and Linâ€™s was written in C++.



In 2011, Lhotak et al., \cite{lhotak2011points} proposed a strong update analysis combining best of both worlds: the efficiency of flow-insensitive analysis and the precision of flow-sensitive analysis through strong updates.
The key insight is the use of strong updates which can be applied when the dereferenced points-to set is a singleton. 
In their approach, singleton points-to sets are tracked using a flow-sensitive analysis, while non-singleton points-to sets are handled using a flow-insensitive analysis.
This hybrid strategy allows flow-sensitive analysis to refine the precision of flow-insensitive points-to information, while the flow-insensitive analysis provides a robust fallback in cases where flow-sensitive tracking would be expensive.
The analysis leverages SSA form which is effective to perform strong updates. Empirical results demonstrated that this hybrid method produces more precise points-to sets compared to purely flow-insensitive or purely flow-sensitive approaches.